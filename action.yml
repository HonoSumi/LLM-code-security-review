name: 'LLM Code Security Reviewer'
description: 'AI-powered security review GitHub Action using LLM to analyze code changes for security vulnerabilities'
author: 'HonoSumi'

inputs:
  comment-pr:
    description: 'Whether to comment on PRs with findings'
    required: false
    default: 'true'
  
  upload-results:
    description: 'Whether to upload results as artifacts'
    required: false
    default: 'true'
  
  exclude-directories:
    description: 'Comma-separated list of directories to exclude from scanning'
    required: false
    default: ''

  LLMcode-timeout:
    description: 'Timeout for LLM analysis in minutes'
    required: false
    default: '20'
  
  LLM-api-key:
    description: 'LLM API key for security analysis'
    required: true
    default: ''

  LLM-model:
    description: 'LLM model to use for security analysis (e.g., deepseek-chat)'
    required: false
    default: ''

  run-every-commit:
    description: 'Run LLM on every commit (skips cache check). Warning: This may lead to more false positives on PRs with many commits as the AI analyzes the same code multiple times.'
    required: false
    default: 'false'

  false-positive-filtering-instructions:
    description: 'Path to custom false positive filtering instructions text file'
    required: false
    default: ''

  custom-security-scan-instructions:
    description: 'Path to custom security scan instructions text file to append to audit prompt'
    required: false
    default: ''

outputs:
  findings-count:
    description: 'Number of security findings'
    value: ${{ steps.LLMcode-scan.outputs.findings_count }}
  
  results-file:
    description: 'Path to the results JSON file'
    value: ${{ steps.LLMcode-scan.outputs.results_file }}

runs:
  using: 'composite'
  steps:
    - name: Install GitHub CLI
      shell: bash
      run: |
        echo "::group::Install gh CLI"
        # Install GitHub CLI for PR operations
        sudo apt-get update && sudo apt-get install -y gh
        echo "::endgroup::"
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'
    
    
    - name: Determine LLM enablement
      id: LLMcode-check
      shell: bash
      run: |
        # Check if LLM should be enabled
        ENABLE_LLMCODE="true"
        SILENCE_LLMCODE_COMMENTS="false"
        
        # For PRs, check sampling and cache
        if [ "${{ github.event_name }}" == "pull_request" ]; then
          PR_NUMBER="${{ github.event.pull_request.number }}"

          # Now check cache - if LLMCode has already run, disable unless run-every-commit is true
          # Check if marker file exists (cache may have been restored from a different SHA)
          if [ "${{ inputs.run-every-commit }}" != "true" ] && [ -f ".LLMcode-marker/marker.json" ]; then
            echo "LLM has already run on PR #$PR_NUMBER (found marker file), forcing disable to avoid false positives"
            ENABLE_LLMCODE="false"
          elif [ "${{ inputs.run-every-commit }}" == "true" ] && [ -f ".LLMcode-marker/marker.json" ]; then
            echo "LLM has already run on PR #$PR_NUMBER but run-every-commit is enabled, running again"
          elif [ "$ENABLE_LLMCODE" == "true" ]; then
            echo "LLM will run for PR #$PR_NUMBER (first run)"
          fi
        fi
        
        echo "enable_LLMcode=$ENABLE_LLMCODE" >> $GITHUB_OUTPUT
        echo "silence_LLMcode_comments=$SILENCE_LLMCODE_COMMENTS" >> $GITHUB_OUTPUT
        
        if [ "$ENABLE_LLMCODE" == "true" ]; then
          echo "LLM is enabled for this run"
        else
          echo "LLM is disabled for this run"
        fi
    
    - name: Reserve LLMcode slot to prevent race conditions
      if: steps.LLMcode-check.outputs.enable_LLMcode == 'true' && github.event_name == 'pull_request'
      shell: bash
      run: |
        # Create a reservation marker immediately to prevent other concurrent runs
        mkdir -p .LLMcode-marker
        cat > .LLMcode-marker/marker.json << EOF
        {
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "repository_id": "${{ github.repository_id }}",
          "repository": "${{ github.repository }}",
          "pr_number": ${{ github.event.pull_request.number }},
          "sha": "${{ github.sha }}",
          "status": "reserved",
          "run_id": "${{ github.run_id }}",
          "run_number": "${{ github.run_number }}"
        }
        EOF
        echo "Created LLM reservation marker for PR #${{ github.event.pull_request.number }}"
    
    - name: Save LLMcode reservation to cache
      if: steps.LLMcode-check.outputs.enable_LLMcode == 'true' && github.event_name == 'pull_request'
      uses: actions/cache/save@v4
      with:
        path: .LLMcode-marker
        key: LLMcode-${{ github.repository_id }}-pr-${{ github.event.pull_request.number }}-${{ github.sha }}
    
    - name: Set up Node.js
      if: steps.LLMcode-check.outputs.enable_LLMcode == 'true'
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Install dependencies
      shell: bash
      run: |
        echo "::group::Install Deps"
        if [ "${{ steps.LLMcode-check.outputs.enable_LLMcode }}" == "true" ]; then
          pip install -r ${{ github.action_path }}/LLMcode/requirements.txt
        fi
        sudo apt-get update && sudo apt-get install -y jq
        echo "::endgroup::"
    
    - name: Run LLMcode scan
      id: LLMcode-scan
      if: steps.LLMcode-check.outputs.enable_LLMcode == 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ github.token }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
        LLM_API_KEY: ${{ inputs.LLM-api-key }}
        ENABLE_LLM_FILTERING: 'true' 
        EXCLUDE_DIRECTORIES: ${{ inputs.exclude-directories }}
        FALSE_POSITIVE_FILTERING_INSTRUCTIONS: ${{ inputs.false-positive-filtering-instructions }}
        CUSTOM_SECURITY_SCAN_INSTRUCTIONS: ${{ inputs.custom-security-scan-instructions }}
        LLM_MODEL: ${{ inputs.LLM-model }}
      run: |
        echo "Running LLMcode AI security analysis..."
        echo "----------------------------------------"
        
        # Initialize outputs
        echo "findings_count=0" >> $GITHUB_OUTPUT
        echo "results_file=LLMcode/LLMcode-results.json" >> $GITHUB_OUTPUT
        
        # Skip LLMcode if not a PR
        if [ "${{ github.event_name }}" != "pull_request" ]; then
          echo "LLMcode only runs on pull requests, skipping"
          exit 0
        fi
                
        # Set timeout
        export LLM_TIMEOUT="${{ inputs.LLMcode-timeout }}"
        
        # Run LLMcode audit with verbose debugging
        export REPO_PATH=$(pwd)
        cd ${{ github.action_path }}
        
        # Enable verbose debugging
        echo "::group::LLMcode Environment"
        echo "Current directory: $(pwd)"
        echo "Python version: $(python --version)"
        echo "LLM_API_KEY set: $(if [ -n "$LLM_API_KEY" ]; then echo 'Yes'; else echo 'No'; fi)"
        echo "GITHUB_REPOSITORY: $GITHUB_REPOSITORY"
        echo "PR_NUMBER: $PR_NUMBER"
        echo "Python path: $PYTHONPATH"
        echo "Files in LLMcode directory:"
        ls -la LLMcode/
        echo "::endgroup::"
        
        echo "::group::LLMcode Execution"
        # Add current directory to Python path so it can find the LLMcode module
        export PYTHONPATH="${PYTHONPATH:+$PYTHONPATH:}$(pwd)"
        echo "Updated PYTHONPATH: $PYTHONPATH"
        
        # Run from the action root directory so Python can find the LLMcode module
        python -u LLMcode/github_action_audit.py > LLMcode/LLMcode-results.json 2>LLMcode/LLMcode-error.log || LLMCODE_EXIT_CODE=$?
        
        if [ -n "$LLMCODE_EXIT_CODE" ]; then
          echo "::warning::LLMcode exited with code $LLMCODE_EXIT_CODE"
        else
          echo "LLMcode scan completed successfully"
        fi
        
        # Parse LLMcode results and count findings regardless of exit code
        if [ -f LLMcode/LLMcode-results.json ]; then
          FILE_SIZE=$(wc -c < LLMcode/LLMcode-results.json)
          echo "LLMcode results file size: $FILE_SIZE bytes"
          
          # Check if file is empty or too small
          if [ "$FILE_SIZE" -lt 2 ]; then
            echo "::warning::LLMcode results file is empty or invalid (size: $FILE_SIZE bytes)"
            echo "::warning::LLMcode may have failed silently. Check LLMcode-error.log"
            if [ -f LLMcode/LLMcode-error.log ]; then
              echo "Error log contents:"
              cat LLMcode/LLMcode-error.log
            fi
            echo "findings_count=0" >> $GITHUB_OUTPUT
          else
            echo "LLMcode results preview:"
            head -n 300 LLMcode/LLMcode-results.json || echo "Unable to preview results"
                        
            # Check if the result is an error
            if jq -e '.error' LLMcode/LLMcode-results.json > /dev/null 2>&1; then
              ERROR_MSG=$(jq -r '.error' LLMcode/LLMcode-results.json)
              echo "::warning::LLMcode error: $ERROR_MSG"
              echo "findings_count=0" >> $GITHUB_OUTPUT
            else
              # Use -r to get raw output and handle potential null/missing findings array
              LLMCODE_FINDINGS_COUNT=$(jq -r '.findings | if . == null then 0 else length end' LLMcode/LLMcode-results.json 2>/dev/null || echo "0")
              echo "::debug::Extracted LLMcode findings count: $LLMCODE_FINDINGS_COUNT"
              echo "findings_count=$LLMCODE_FINDINGS_COUNT" >> $GITHUB_OUTPUT
              echo "LLMcode found $LLMCODE_FINDINGS_COUNT security issues"
              
              # Also create findings.json for PR comment script
              jq '.findings // []' LLMcode/LLMcode-results.json > findings.json || echo '[]' > findings.json
            fi
          fi
        else
          echo "::warning::LLMcode results file not found"
          if [ -f LLMcode/LLMcode-error.log ]; then
            echo "Error log contents:"
            cat LLMcode/LLMcode-error.log
          fi
          echo "findings_count=0" >> $GITHUB_OUTPUT
        fi
        
        # Always copy files to workspace root regardless of the outcome
        # This ensures artifact upload and PR commenting can find them
        if [ -f findings.json ]; then
          cp findings.json ${{ github.workspace }}/findings.json || true
        fi
        if [ -f LLMcode/LLMcode-results.json ]; then
          cp LLMcode/LLMcode-results.json ${{ github.workspace }}/LLMcode-results.json || true
        fi
        if [ -f LLMcode/LLMcode-error.log ]; then
          cp LLMcode/LLMcode-error.log ${{ github.workspace }}/LLMcode-error.log || true
        fi
        
        echo "::endgroup::"
    
    
    - name: Upload scan results
      if: always() && inputs.upload-results == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: security-review-results
        path: |
          findings.json
          LLMcode-results.json
          LLMcode-error.log
        retention-days: 7
        if-no-files-found: ignore
    
    - name: Comment PR with findings
      if: github.event_name == 'pull_request' && inputs.comment-pr == 'true' && steps.LLMcode-check.outputs.enable_LLMcode == 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ github.token }}
        LLMCODE_FINDINGS: ${{ steps.LLMcode-scan.outputs.findings_count }}
        SILENCE_LLMCODE_COMMENTS: ${{ steps.LLMcode-check.outputs.silence_LLMcode_comments }}
      run: |
        node ${{ github.action_path }}/scripts/comment-pr-findings.js

branding:
  icon: 'shield'
  color: 'red'
